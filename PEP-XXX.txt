PEP: XXX
Title: Support for indexing with keyword arguments.
Version: $Revision: 41421 $
Last-Modified: $Date: 2005-11-10 06:42:20 -0800 (Thu, 10 Nov 2005) $
Author: Joseph Martinot-Lagarde <joseph.martinot-lagarde@...>, Stefano Borini <stefano.borini@gmail.com>
Discussion-To: python-ideas@python.org
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 24-Jun-2014
Python-Version: 3.6
Post-History: 

Abstract
========

This PEP proposes an extension of the indexing operation to support keyword
arguments.  Notations in the form a[k=3], or a[1:2, k=3, r=5] would become
legal syntax. In addition to a change in the parser, the index protocol
(__getitem__, __setitem__ and __delitem__) will also require adaptation. 

Motivation
==========

The current syntax of the indexing operation provides the following 
strategies for access 

   >>> a[3]       # returns the third element of a
   >>> a[1:10:2]  # slice notation (extract a subset of the data)
   >>> a[3,2]     # multiple indexes (e.g. for multidimensional arrays)

The additional notation proposed in this PEP would allow notations involving
keyword arguments in the indexing operation, e.g.

   >>> a[K=3]
   >>> a[3,R=3,K=4]

The following practical use cases for this notation present two broad categories
of usage of a keyworded specification in indexing: as an index, and as an option
contextual to the indexing:

1. In some domain, such as computational physics and chemistry, the use of a
notation such as Basis[Z=5] is a Domain Specific Language notation to represent 
a level of accuracy

  >>> low_accuracy_energy = computeEnergy(molecule, BasisSet[Z=3])

In this case, the index operation would return a basis set at the chosen level
of accuracy (represented by the parameter Z)

2. To provide a more communicative meaning to the index, preventing e.g. accidental
   inversion of indexes

  >>> gridValues[x=3, y=5, z=8]
  >>> rain[time=0:12, location=location]

3. A "default" option allows to specify a default return value when the index
   is not present

  >>> lst = [1, 2, 3]
  >>> value = lst[5, default=0]  # value is 0

4. For a sparse dataset, to specify an interpolation strategy 
   to infer a missing point from e.g. its surrounding data.

 >>> value = array[1, 3, interpolate=spline_interpolator]

5. A unit could be specified with the same mechanism

  >>> value = array[1, 3, unit="degrees"]

How the notation is interpreted is up to the implementing class. 

Current implementation
======================

Currently, the indexing operation is handled by methods __getitem__,
__setitem__ and __delitem__. These methods' signature accept one argument
for the index (with __setitem__ accepting an additional argument for the set
value). In the following, we will analyze __getitem__(self, idx) exclusively,
with the same considerations implied for the remaining two methods.

When an indexing operation is performed, __getitem__(self, idx) is called.
Traditionally, the full content between square brackets is turned into a single
object passed to argument idx:

    - When a single element is passed, e.g. a[2], idx will be 2.
    - When multiple elements are passed, they must be separated by commas: a[2,3].
      In this case, idx will be a tuple (2,3). With a[2,3,"hello",{}] 
      idx will be (2,3,"hello",{}).
    - A slicing notation e.g. a{2:10] will produce a slice object, or a tuple
      containing slice objects if multiple values were passed.

Except for its unique ability to handle slice notation, the indexing operation
has similarities to a plain method call: it acts like one when invoked with
only one element; If the number of elements is greater than one, the
idx argument behaves like a *args. However, an indexing operation has the
strong semantic implication of extraction of a subset out of a larger set,
which is not present in a regular method call, and its different visual style
is important for readability.

Specifications
==============

The implementation should try to preserve the current signature for
__getitem__, or modify it in a backward-compatible way. We will present
different alternatives, keeping into account the possible cases that need
to be addressed

        C0. a[3]; a[3,2] (Traditional indexing)
	C1. a[Z=3] 
	C2. a[Z=3, R=2]
	C3. a[1, Z=3]
	C4. a[1, Z=3, R=2]
	C5. a[1, 2, Z=3]
	C6. a[1, 2, Z=3, R=4]
	C7. a[1, Z=3, 2, R=4]

The possible strategies for __getitem__ are:

Strategy 1: 
----------------------
Keep the current signature for __getitem__, and expand the range of variability in
type and contents of the current idx parameter.

	C0: a[2]        -> idx = 2        # integer
            a[2,3]      -> idx = (2,3)    # tuple
        C1: a[Z=3]      -> idx = {"Z": 3} # dictionary with single key
        C2. a[Z=3, R=4] -> idx = {"Z": 3, "R": 4}     # dictionary with two keys.[1]
                        or idx = ({"Z": 3}, {"R": 4}) # tuple of two dictionaries, 
                                                      # each with a single key. [2]

[1] Naturally maps to the traditional **kwargs behavior, however it breaks
    the convention that two or more entries for the index produce a tuple. 
[2] preserves the above behavior, and additionally preserves the order. 
    Preserving the order is also possible with an OrderedDict as drafted by PEP-468.

	C3. a[1, Z=3]   -> idx = (1, {"Z":3}) 

Case 4,5,6:

As in case a[1, Z=3, R=2] two possible implementations exist
  a. idx becomes the two-values tuple (1, {"Z":3, "R": 4})
  b. idx becomes the three values tuple (1, {"Z": 3}, {"R": 4})


Case 7:

There are three possible choices for case 7:
  a. Pack all keyword arguments in the dictionary, to produce idx = (1, 2, {"Z": 3, "R": 4}. Ugly and unexpected.
  b. Keep using the one-key dictionary strategy to produce (1, {"Z": 3}, 3, {"R": 4})
  c. Forbid the notation altogether, like in the case of function calls.

Solution c is the most consistent with the behavior of python and keyword
arguments, and so should be preferred.

 Alter the 
   - In "Specifications", I don't like the fact that idx would sometimes be
   a dictionary, sometimes a tuple, and sometimes anything (with a single
   index). Also I don't like the tuple of one-element dictionnaries, it looks
   ugly to me (I'm not against it either, it does the job) and would be a
   mess  to parse. So I have 2 other proposal:


Strategy 2: kwargs argument
---------------------------
__getitem__ accepts an optional **kwargs argument which should be keyword only. 
idx also becomes optional to support a case where no non-keyword arguments are allowed.
The signature would then be either 

	__getitem__(self, idx) 
	__getitem__(self, idx, **kwargs), 
	__getitem__(self, **kwargs) 

This would render point 7 impossible and would be more consistent with
function calls. It doesn't preserve order, but I admit that I
don't see the need for it. 

Strategy 3: named tuple
-----------------------

Always return a namedtuple for idx instead of a tuple. 
Keyword arguments would obviousely have their key as key, and positional
argument would have an underscore followed by their order:

        C0. a[2]; a[2,3]      -> idx = 3; idx=(_1=2, _2=3)
	C1. a[Z=3]            -> idx = (Z=3)
	C2. a[Z=3, R=2]       -> idx = (Z=3, R=2)
	C3. a[1, Z=3]         -> idx = (_1=1, Z=3) 
	C4. a[1, Z=3, R=2]    -> idx = (_1=1, Z=3, R=2)
	C5. a[1, 2, Z=3]      -> idx = (_1=1, _2=2, Z=3)
	C6. a[1, 2, Z=3, R=4] -> (_1=1, _2=2, Z=3, R=4)
	C7. a[1, Z=3, 2, R=4] -> (_1=1, Z=3, _2=2, R=4) or
                                 (_1=1, Z=3, _3=2, R=4) or 
				 invalid ?

The required typename of the namedtuple could be "Index" or the name of the
argument in the function definition, it keeps the ordering and is easy to
analyse by using the _fields attribute. It is backward compatible, provided
that C0 with more than one entry now passes a namedtuple instead of a plain
tuple.  It should be faster than creating many one element dictionaries, too.


	   -

	   data['key'; 0] is not very obvious and it works only for the
	default value. Also visually, ";" is not far from ",".

	   - The alternative of using a slice to set default value should be noted,
	   I find it quite interesting: data['key', 'default':0]. It is not possible
	   to set a slice as the default, though (I mean using slice notation, it is
	   always possible to use slice()).







a dictionary 

The keyword would be keywords-only because right now when many arguments 
are passed to __getitem__, they are grouped in a tuple and this tuple is 
passed to __getitem__ as a unique argument. Also it is more clear: 
ordered arguments are the indexes, keyword arguments are the options.

To be perfectly honest I don't think that this proposal is that great, 
it's main selling point is that a "default" keyword in indexing would be 
a good alternative for some of the problems raised in PEP 463.







========================


Ian Cordasco:
    And the same would be true of your proposed feature for __getitem__
    because all keyword arguments would be collected into one dictionary.
    It would be unreasonable for just one method to behave totally
    differently from the standard behaviour in Python. It would be
    confusing for only __getitem__ (and ostensibly, __setitem__) to take
    keyword arguments but instead of turning them into a dictionary, turn
    them into individual single-item dictionaries.


Note: having a[1,k=2] map to y=(1,{"k":2}) makes it impossible to differentiate from
a[1,{"k": 2}], which may be indended. What about a[1,{"k":2, "r":3}] then? 

Alternate approaches
====================

The first obvious alternate approach is not to introduce this extension,
to keep the indexing as is, and use a
traditional function call. This is certainly a possible approach, but it would
lose the ordering information of the entries. PEP-468 tries to address this.
Another shortcoming is that a mixed situation requiring a slice would result
more awkward. Compare e.g. a[1:3, Z=2] with a.get(slice(1,3,None), Z=2).






----------------------------------------
same.) I think it would be better if the key were syntactically 
separated from a default, say with ;.
   value = lst[3; 0]

I believe any proposal along this line would make dict.getitem obsolete, 
and eliminate any call for list.getitem.

> I use something similar for a dictionary-like interface where the keys
> are strings and only numbers are stored. The second argument, if given,
> is the default:
>  >>> data["key", 0]
> It would be clearer to use:
>  >>> data["key", default=0]

I see data['key'; 0] as an in between compromise. The 0 is separated 
from the key but without the heavy 'default='.

> (Of course I could use a get method for this purpose, but bracket for
> indexing seems always more clear).


-------------------------------


An interesting idea, but that looks far too much like a function call.
Square brackets and then more and more a function call inside... may
fail the grit test.

Part of the point of except expressions was that the implementation of
__getitem__ wouldn't need to have two branches in it. Currently, you
need to write __getitem__ (which raises an exception on finding a
problem) plus something else, eg get(), which returns a default
instead. By your proposal, both branches would go inside __getitem__,
which means they could share code; but there still need to be two
branches. That's two branches that need to be written, tested, etc,
and if the author hasn't thought to handle default=, there's no way to
get that functionality, same as if there's no get() method. And just
as with the get method, there'll be an ad-hoc and fairly arbitrary
puddle of names (some will go "default=", others will say that's way
too long and go "def=", except that that's a keyword so they'll use
"dflt=" or something...), unless there's a strong force pushing people
to one consistent name. Terry's suggestion solves that part of it, but
also restricts the feature to just default values; with a more general
keyword argument system, it would make sense to also use this with
__setitem__ and __delitem__, and I'm not sure how "default value"
should be interpreted there. Which is better is, of course, a matter
of opinion! :)

ChrisA

> Part of the point of except expressions was that the implementation of
> __getitem__ wouldn't need to have two branches in it.

> Currently, you
> need to write __getitem__ (which raises an exception on finding a
> problem) plus something else, eg get(), which returns a default
> instead. By your proposal, both branches would go inside __getitem__,
> which means they could share code; but there still need to be two
> branches. That's two branches that need to be written, tested, etc,
> and if the author hasn't thought to handle default=, there's no way to
> get that functionality, same as if there's no get() method.

> And just
> as with the get method, there'll be an ad-hoc and fairly arbitrary
> puddle of names (some will go "default=", others will say that's way
> too long and go "def=", except that that's a keyword so they'll use
> "dflt=" or something...), unless there's a strong force pushing people
> to one consistent name.

Well, this argument would hold against using keywords arguments in any 
function call.

> Terry's suggestion solves that part of it, but
> also restricts the feature to just default values; with a more general
> keyword argument system, it would make sense to also use this with
> __setitem__ and __delitem__, and I'm not sure how "default value"
> should be interpreted there. Which is better is, of course, a matter
> of opinion! :)

setitem and delitem don't look like function calls at all IMHO. Keywords 
arguments for them would be less useful than for getitem.


References
==========

http://article.gmane.org/gmane.comp.python.ideas/27584
https://mail.python.org/pipermail/python-ideas/2014-June/028164.html


Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
